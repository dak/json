## Reasons to Use JSON

1.  JSON is more compact, meaning smaller file sizes to send to a client
    PHIL: The webserver sends GZIP'd documents and my guess is that there is minimal overhead since regexp's can convert the JSON doc to HTML and back.
2.  JSON is [formal and precise](http://json.org/), so there's less possibility of ambiguity or exceptions
    PHIL: So is XML
3.  JSON is **much** faster to parse than XML, and you don't need to write any custom code to parse it
    PHIL: In every use case of CollXML, the exact same HTML must be used (PDFs, EPUB, online, editor, transfer between services)
    1.  Current code to parse a book (already broken with new COLLXML format, and code complexity increases exponentially with more features):
          `````
          parseHTML = (html) ->
            if typeof html isnt 'string' then return []

            results = []

            $(html).find('> ol').find('> li').each (index, el) ->
              $el = $(el)
              $node = $el.children().eq(0)

              if $node.is('a')
                id = $node.attr('href')
                title = $node.text()

              # Only remember the title if it's overridden
              if not title or $node.hasClass('autogenerated-text')
                results.push({id: id})
              else
                results.push({id: id, title: title})

            return results
          `````
    PHIL: Serializing JSON to HTML is equally "complex"

    2.  No code is required to parse JSON, since support is built-in to Backbone, but if you needed to, it would always be one line:
        PHIL: It's also 1 line for XML.
        1.  ```JSON.parse(string)``` in JavaScript
        PHIL: jQuery(html)
        2.  In Python, just ```import json``` and then ```json.loads(string)```
        PHIL: import lxml; lxml.parse(xmlStr)

3.  JSON, unlike XML, matches the data model of most programming languages
    1.  Literally "JavaScript Object Notation", it can be serialized and parsed back into an object in any modern browser
    2.  Maps easily to Python as well: Object = Dictionary, Array = List, etc.
4.  Support for JSON has [only been growing](http://blog.appfog.com/why-json-will-continue-to-push-xml-out-of-the-picture/) as it is becoming the default data exchange format for the web
5.  PostgreSQL has built-in support for JSON, including automatic validation
    PHIL: PostgreSQL has building support for XML https://wiki.postgresql.org/wiki/XML_Support with support for complex queries (XPath) and conversion (XSLT)
    1.  http://www.postgresql.org/docs/devel/static/datatype-json.html
    2.  http://www.postgresql.org/docs/9.3/static/functions-json.html
6.  [Backbone.js](http://backbonejs.org) is designed to work with specifically with JSON
    PHIL: Backbone is **not** designed to work with Objects as attributes (trees)
    1.  "Backbone.js gives structure to web applications ... and connects it all to your existing API over a RESTful **JSON** interface."
7.  An XML or HTML markup of a book can be generated from data more easily and quickly than XML can be parsed into data
PHIL: Examples?
8.  A template (or multiple templates) could be used to easily convert data into any format, simplifying support for different formats.  So, for example, we should be able to avoid restyling every book.
PHIL: All of the formats (use cases) are HTML and styling is done in CSS
9.  Because of things like xincludes, XML must be parsed into data, manipulated, and then re-generated.  Storing as JSON skips the first step, because it already _is_ data.
PHIL: Parsing the data is $xml.find('.xinclude').each ($node) => jQuery.get($node.attr('href'))

10. We're **already** using JSON.  Currently, the XML/HTML is simply being served as a JSON field.  Serving just JSON would simplify it to a single data format.
PHIL: We're already using XML for all of our content

11. Folders are already serving their contents as JSON.

12. ATC is effectively just taking the HTML/XML being served currently and converting it into a JavaScript Object (JSON).
